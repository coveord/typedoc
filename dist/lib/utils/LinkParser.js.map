{"version":3,"file":"LinkParser.js","sourceRoot":"","sources":["../../../src/lib/utils/LinkParser.ts"],"names":[],"mappings":";;AAAA,2BAA6B;AAQ7B;IAiBE,oBAAY,OAA0B,EAAE,UAAmB;QARnD,cAAS,GAAW,+DAA+D,CAAC;QAKpF,cAAS,GAAW,oBAAoB,CAAC;QAI/C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,UAAU,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC;IACzD,CAAC;IAQO,sCAAiB,GAAzB,UAA0B,IAAY;QAAtC,iBAaC;QAZC,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,UAAC,KAAa,EAAE,OAAe,EAAE,OAAe,EAAE,OAAe;YACnG,IAAM,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAC1C,IAAM,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;YAC5B,IAAM,OAAO,GAAG,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC;YAEzC,IAAI,SAAkB,CAAC;YACvB,EAAE,CAAC,CAAC,OAAO,KAAK,UAAU,CAAC,CAAC,CAAC;gBAAC,SAAS,GAAG,IAAI,CAAC;YAAC,CAAC;YACjD,EAAE,CAAC,CAAC,OAAO,KAAK,WAAW,CAAC,CAAC,CAAC;gBAAC,SAAS,GAAG,KAAK,CAAC;YAAC,CAAC;YAEnD,MAAM,CAAC,KAAI,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;QAC3D,CAAC,CAAC,CAAC;IACL,CAAC;IAWO,8BAAS,GAAjB,UAAkB,QAAgB,EAAE,MAAc,EAAE,OAAe,EAAE,SAAmB;QACtF,IAAI,UAAU,GAAG,EAAE,CAAC;QACpB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;YAChC,UAAU,GAAG,mBAAmB,CAAC;QACnC,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,UAAU,SAAY,CAAC;YAC3B,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;YAEvD,EAAE,CAAC,CAAC,UAAU,IAAI,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;gBACjC,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC;YAC1B,CAAC;YAAC,IAAI,CAAC,CAAC;gBAEN,MAAM,CAAC,OAAO,CAAC;YACjB,CAAC;QACH,CAAC;QAED,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACd,OAAO,GAAG,QAAQ,GAAG,OAAO,GAAG,SAAS,CAAC;QAC3C,CAAC;QAED,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,yBAAyB,EAAE,IAAI,CAAC,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;IAC9F,CAAC;IAOM,kCAAa,GAApB,UAAqB,IAAY;QAC/B,MAAM,CAAC,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;IAQO,kCAAa,GAArB,UAAsB,IAAY;QAChC,IAAI,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACnC,EAAE,CAAC,CAAC,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACtB,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QACjC,CAAC;QAED,EAAE,CAAC,CAAC,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC;gBACL,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;gBACxD,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,UAAU,CAAC;aACnC,CAAC;QACJ,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,MAAM,CAAC;gBACL,OAAO,EAAE,IAAI;gBACb,MAAM,EAAE,IAAI;aACb,CAAC;QACJ,CAAC;IACH,CAAC;IACH,iBAAC;AAAD,CAAC,AA5GD,IA4GC;AA5GY,gCAAU","sourcesContent":["import * as Util from 'util';\r\n\r\nimport { Reflection } from '../models/reflections/abstract';\r\nimport { ProjectReflection } from '../models/reflections/index';\r\n\r\n/**\r\n * A plugin that builds links in markdown texts.\r\n */\r\nexport class LinkParser {\r\n  /**\r\n   * The project that is currently processed.\r\n   */\r\n  private project: ProjectReflection;\r\n\r\n  /**\r\n   * Regular expression for detecting inline tags like {@link ...}.\r\n   */\r\n  private inlineTag: RegExp = /(?:\\[(.+?)\\])?\\{@(link|linkcode|linkplain)\\s+((?:.|\\n)+?)\\}/gi;\r\n\r\n  /**\r\n   * Regular expression to test if a string looks like an external url.\r\n   */\r\n  private urlPrefix: RegExp = /^(http|ftp)s?:\\/\\//;\r\n  private linkPrefix: string;\r\n\r\n  constructor(project: ProjectReflection, linkPrefix?: string) {\r\n    this.project = project;\r\n    this.linkPrefix = linkPrefix != null ? linkPrefix : '';\r\n  }\r\n\r\n  /**\r\n   * Find symbol {@link ...} strings in text and turn into html links\r\n   *\r\n   * @param text  The string in which to replace the inline tags.\r\n   * @return      The updated string.\r\n   */\r\n  private replaceInlineTags(text: string): string {\r\n    let that = this;\r\n    return text.replace(this.inlineTag, (match: string, leading: string, tagName: string, content: string): string => {\r\n      const split = that.splitLinkText(content);\r\n      const target = split.target;\r\n      const caption = leading || split.caption;\r\n\r\n      let monospace: boolean;\r\n      if (tagName === 'linkcode') { monospace = true; }\r\n      if (tagName === 'linkplain') { monospace = false; }\r\n\r\n      return this.buildLink(match, target, caption, monospace);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Format a link with the given text and target.\r\n   *\r\n   * @param original   The original link string, will be returned if the target cannot be resolved..\r\n   * @param target     The link target.\r\n   * @param caption    The caption of the link.\r\n   * @param monospace  Whether to use monospace formatting or not.\r\n   * @returns A html link tag.\r\n   */\r\n  private buildLink(original: string, target: string, caption: string, monospace?: boolean): string {\r\n    let attributes = '';\r\n    if (this.urlPrefix.test(target)) {\r\n      attributes = ' class=\"external\"';\r\n    } else {\r\n      let reflection: Reflection;\r\n      reflection = this.project.findReflectionByName(target);\r\n\r\n      if (reflection && reflection.url) {\r\n        target = reflection.url;\r\n      } else {\r\n        // console.log('Link could not be resolved : ' + original);\r\n        return caption;\r\n      }\r\n    }\r\n\r\n    if (monospace) {\r\n      caption = '<code>' + caption + '</code>';\r\n    }\r\n\r\n    return Util.format('<a href=\"%s%s\"%s>%s</a>', this.linkPrefix, target, attributes, caption);\r\n  }\r\n\r\n  /**\r\n   * Triggered when [[MarkedPlugin]] parses a markdown string.\r\n   *\r\n   * @param event\r\n   */\r\n  public parseMarkdown(text: string) {\r\n    return this.replaceInlineTags(text);\r\n  }\r\n\r\n  /**\r\n   * Split the given link into text and target at first pipe or space.\r\n   *\r\n   * @param text  The source string that should be checked for a split character.\r\n   * @returns An object containing the link text and target.\r\n   */\r\n  private splitLinkText(text: string): { caption: string; target: string; } {\r\n    let splitIndex = text.indexOf('|');\r\n    if (splitIndex === -1) {\r\n      splitIndex = text.search(/\\s/);\r\n    }\r\n\r\n    if (splitIndex !== -1) {\r\n      return {\r\n        caption: text.substr(splitIndex + 1).replace(/\\n+/, ' '),\r\n        target: text.substr(0, splitIndex)\r\n      };\r\n    } else {\r\n      return {\r\n        caption: text,\r\n        target: text\r\n      };\r\n    }\r\n  }\r\n}\r\n"]}