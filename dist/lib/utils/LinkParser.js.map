{"version":3,"file":"LinkParser.js","sourceRoot":"","sources":["../../../src/lib/utils/LinkParser.ts"],"names":[],"mappings":";;AAAA,6BAA6B;AAS7B,MAAa,UAAU;IAkBrB,YAAY,OAA0B,EAAE,UAAmB;QATnD,cAAS,GAAW,+DAA+D,CAAC;QAKpF,cAAS,GAAW,oBAAoB,CAAC;QAK/C,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,UAAU,IAAI,IAAI,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC;IACzD,CAAC;IASO,iBAAiB,CAAC,IAAY;QACpC,IAAI,IAAI,GAAG,IAAI,CAAC;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,EAAE,CAAC,KAAa,EAAE,OAAe,EAAE,OAAe,EAAE,OAAe,EAAU,EAAE;YAC/G,IAAI,KAAK,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YACxC,IAAI,MAAM,GAAG,KAAK,CAAC,MAAM,CAAC;YAC1B,IAAI,OAAO,GAAG,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC;YAEvC,IAAI,SAAS,GAAY,OAAO,IAAI,UAAU,CAAC;YAE/C,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;QAC3D,CAAC,CAAC,CAAC;IACL,CAAC;IAYO,SAAS,CAAC,QAAgB,EAAE,MAAc,EAAE,OAAe,EAAE,SAAmB;QACtF,IAAI,UAAU,GAAG,EAAE,CAAC;QACpB,IAAI,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YAC/B,UAAU,GAAG,mBAAmB,CAAC;SAClC;aAAM;YACL,IAAI,UAAsB,CAAC;YAC3B,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;YAEvD,IAAI,UAAU,IAAI,UAAU,CAAC,GAAG,EAAE;gBAChC,MAAM,GAAG,UAAU,CAAC,GAAG,CAAC;aACzB;iBAAM;gBAEL,OAAO,OAAO,CAAC;aAChB;SACF;QAED,IAAI,SAAS,EAAE;YACb,OAAO,GAAG,QAAQ,GAAG,OAAO,GAAG,SAAS,CAAC;SAC1C;QAED,OAAO,IAAI,CAAC,MAAM,CAAC,yBAAyB,EAAE,IAAI,CAAC,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC;IAC9F,CAAC;IAQM,aAAa,CAAC,IAAY;QAC/B,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;IACtC,CAAC;IASO,aAAa,CAAC,IAAY;QAChC,IAAI,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACnC,IAAI,UAAU,KAAK,CAAC,CAAC,EAAE;YACrB,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;SAChC;QAED,IAAI,UAAU,KAAK,CAAC,CAAC,EAAE;YACrB,OAAO;gBACL,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;gBACxD,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,UAAU,CAAC;aACnC,CAAC;SACH;aAAM;YACL,OAAO;gBACL,OAAO,EAAE,IAAI;gBACb,MAAM,EAAE,IAAI;aACb,CAAC;SACH;IACH,CAAC;CACF;AA/GD,gCA+GC","sourcesContent":["import * as Util from \"util\";\n\n\nimport { Reflection } from \"../models/reflections/abstract\";\nimport { ProjectReflection } from \"../models/reflections/index\";\n\n/**\n * A plugin that builds links in markdown texts.\n */\nexport class LinkParser {\n  /**\n   * The project that is currently processed.\n   */\n  private project: ProjectReflection;\n\n  /**\n   * Regular expression for detecting inline tags like {@link ...}.\n   */\n  private inlineTag: RegExp = /(?:\\[(.+?)\\])?\\{@(link|linkcode|linkplain)\\s+((?:.|\\n)+?)\\}/gi;\n\n  /**\n   * Regular expression to test if a string looks like an external url.\n   */\n  private urlPrefix: RegExp = /^(http|ftp)s?:\\/\\//;\n  private linkPrefix: string;\n\n\n  constructor(project: ProjectReflection, linkPrefix?: string) {\n    this.project = project;\n    this.linkPrefix = linkPrefix != null ? linkPrefix : '';\n  }\n\n\n  /**\n   * Find symbol {@link ...} strings in text and turn into html links\n   *\n   * @param text  The string in which to replace the inline tags.\n   * @return      The updated string.\n   */\n  private replaceInlineTags(text: string): string {\n    let that = this;\n    return text.replace(this.inlineTag, (match: string, leading: string, tagName: string, content: string): string => {\n      var split = that.splitLinkText(content);\n      var target = split.target;\n      var caption = leading || split.caption;\n\n      var monospace: boolean = tagName == 'linkcode';\n\n      return this.buildLink(match, target, caption, monospace);\n    });\n  }\n\n\n  /**\n   * Format a link with the given text and target.\n   *\n   * @param original   The original link string, will be returned if the target cannot be resolved..\n   * @param target     The link target.\n   * @param caption    The caption of the link.\n   * @param monospace  Whether to use monospace formatting or not.\n   * @returns A html link tag.\n   */\n  private buildLink(original: string, target: string, caption: string, monospace?: boolean): string {\n    let attributes = '';\n    if (this.urlPrefix.test(target)) {\n      attributes = ' class=\"external\"';\n    } else {\n      let reflection: Reflection;\n      reflection = this.project.findReflectionByName(target);\n\n      if (reflection && reflection.url) {\n        target = reflection.url;\n      } else {\n        //console.log('Link could not be resolved : ' + original);\n        return caption;\n      }\n    }\n\n    if (monospace) {\n      caption = '<code>' + caption + '</code>';\n    }\n\n    return Util.format('<a href=\"%s%s\"%s>%s</a>', this.linkPrefix, target, attributes, caption);\n  }\n\n\n  /**\n   * Triggered when [[MarkedPlugin]] parses a markdown string.\n   *\n   * @param event\n   */\n  public parseMarkdown(text: string) {\n    return this.replaceInlineTags(text);\n  }\n\n\n  /**\n   * Split the given link into text and target at first pipe or space.\n   *\n   * @param text  The source string that should be checked for a split character.\n   * @returns An object containing the link text and target.\n   */\n  private splitLinkText(text: string): { caption: string; target: string; } {\n    var splitIndex = text.indexOf('|');\n    if (splitIndex === -1) {\n      splitIndex = text.search(/\\s/);\n    }\n\n    if (splitIndex !== -1) {\n      return {\n        caption: text.substr(splitIndex + 1).replace(/\\n+/, ' '),\n        target: text.substr(0, splitIndex)\n      };\n    } else {\n      return {\n        caption: text,\n        target: text\n      };\n    }\n  }\n}\n"]}